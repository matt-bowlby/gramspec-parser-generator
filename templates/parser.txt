use std::error::Error;
use std::collections::HashMap;
use regex::Regex;

use expression::Expression::{self, *};
use node::{Node, NodeType::*};

const KEYWORDS: &[(&str, &str)] = &[
_TS_("ENDMARKER", "0"),
];

#[allow(dead_code)]
pub struct _PARSERNAME_ {
_TS_pub position: usize,
_TS_pub debug: bool,

_TS_content: std::string::String,
_TS_memos: HashMap<usize, HashMap<std::string::String, Box<Option<Vec<Node>>>>>,
}

#[allow(dead_code)]
impl _PARSERNAME_ {
_TS_pub fn new() -> Self {
_TS__TS__PARSERNAME_ { content: std::string::String::new(), position: 0, memos: HashMap::new(), debug: false }
_TS_}

_TS_pub fn enable_debug(mut self) -> Self {
_TS__TS_self.debug = true;
_TS__TS_self
_TS_}

_TS_fn debug_log(&self, message: &str) {
_TS__TS_if self.debug {
_TS__TS__TS_println!("DEBUG: {} | Position: {} | Next chars: {:?}",
_TS__TS__TS__TS_message,
_TS__TS__TS__TS_self.position,
_TS__TS__TS__TS_self.content.chars().skip(self.position).take(20).collect::<std::string::String>()
_TS__TS__TS_);
_TS__TS__TS_let mut input = std::string::String::new();
_TS__TS__TS_std::io::stdin().read_line(&mut input).unwrap();
_TS__TS_}
_TS_}

_TS_pub fn parse(&mut self, input: std::string::String) -> Result<Option<Node>, Box<dyn Error>> {
_TS__TS_self.position = 0;
_TS__TS_self.content = input;
_TS__TS_if let Some(nodes) = self.__ENTRYRULE_()? {
_TS__TS__TS_let nodes = self.clear_discard_nodes(nodes);
_TS__TS__TS_return Ok(Some(nodes[0].clone()));
_TS__TS_}
_TS__TS_Ok(None)
_TS_}

_TS_pub fn parse_file(&mut self, file_path: &str) -> Result<Option<Node>, Box<dyn Error>> {
_TS__TS_let content = std::fs::read_to_string(file_path)?;
_TS__TS_self.parse(content)
_TS_}

_TS_fn clear_discard_nodes(&self, nodes: Vec<Node>) -> Vec<Node> {
_TS__TS_nodes.into_iter()
_TS__TS__TS_.filter(|node| node.node_type != _Discard)
_TS__TS__TS_.map(|mut node| {
_TS__TS__TS__TS_node.children = self.clear_discard_nodes(node.children);
_TS__TS__TS__TS_node
_TS__TS__TS_})
_TS__TS__TS_.collect()
_TS_}

_TS_fn circular_wrapper(&mut self, rule_name: std::string::String) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let pos = self.position;

_TS__TS_if let Some(cached_result_box) = self.memos.get(&pos).and_then(|memo| memo.get(&rule_name)) {
_TS__TS__TS_let cached_result = *cached_result_box.clone();

_TS__TS__TS_let end_pos = cached_result.as_ref()
_TS__TS__TS__TS_.and_then(|nodes| nodes.iter().map(|n| n.get_end_pos()).max())
_TS__TS__TS__TS_.unwrap_or(pos);
_TS__TS__TS_self.position = end_pos;

_TS__TS__TS_return Ok(cached_result);
_TS__TS_}

_TS__TS_self.memos.entry(pos).or_insert_with(HashMap::new).insert(rule_name.clone(), Box::new(None));

_TS__TS_let mut last_result = None;
_TS__TS_let mut last_pos = pos;

_TS__TS_loop {
_TS__TS__TS_self.position = pos;

_TS__TS__TS_let result = self.call_rule(&rule_name, false)?;
_TS__TS__TS_let end_pos = self.position;

_TS__TS__TS_if end_pos <= last_pos {
_TS__TS__TS__TS_break;
_TS__TS__TS_}

_TS__TS__TS_last_result = result;
_TS__TS__TS_last_pos = end_pos;

_TS__TS__TS_if let Some(memo) = self.memos.get_mut(&pos) {
_TS__TS__TS__TS_memo.insert(rule_name.clone(), Box::new(last_result.clone()));
_TS__TS__TS_}
_TS__TS_}

_TS__TS_// If the result was a failure, remove it from the cache to prevent poisoning
_TS__TS_if last_result.is_none() {
_TS__TS__TS_if let Some(memo) = self.memos.get_mut(&pos) {
_TS__TS__TS__TS_memo.remove(&rule_name);
_TS__TS__TS_}
_TS__TS_}

_TS__TS_self.position = last_pos;
_TS__TS_Ok(last_result)
_TS_}

_TS_fn expect_string(&mut self, string: &str) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_self.debug_log(&format!("Expect string: '{}'", string));
_TS__TS_let mut start_pos = self.position;
_TS__TS_loop {
_TS__TS__TS_if self.content[self.position..].starts_with(string) {
_TS__TS__TS__TS_self.position += string.len();
_TS__TS__TS__TS_return Ok(Some(vec![Node::new_with_position(_String, vec![], Some(string.to_string()), start_pos, self.position)]));
_TS__TS__TS_} else {
_TS__TS__TS__TS_if let Some(whitespace) = Regex::new(r"^[^\S\r\n]+").unwrap().find(&self.content[self.position..]) {
_TS__TS__TS__TS__TS_start_pos += whitespace.end();
_TS__TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS_}
_TS__TS__TS_}
_TS__TS_}
_TS__TS_self.position = start_pos;
_TS__TS_Ok(None)
_TS_}

_TS_fn expect_regex(&mut self, regex: &str) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_self.debug_log(&format!("Expect regex: '{}'", regex));
_TS__TS_let mut start_pos = self.position;
_TS__TS_loop {
_TS__TS__TS_if let Some(captures) = Regex::new(regex).unwrap().captures(&self.content[self.position..]) {
_TS__TS__TS__TS_self.position += captures.get(0).unwrap().end();
_TS__TS__TS__TS_return Ok(Some(vec![Node::new_with_position(
_TS__TS__TS__TS__TS__String,
_TS__TS__TS__TS__TS_vec![],
_TS__TS__TS__TS__TS_Some(captures.get(0).unwrap().as_str().to_string()),
_TS__TS__TS__TS__TS_start_pos,
_TS__TS__TS__TS__TS_self.position
_TS__TS__TS__TS_)]));
_TS__TS__TS_} else {
_TS__TS__TS__TS_if let Some(whitespace) = Regex::new(r"^[^\S\r\n]+").unwrap().find(&self.content[self.position..]) {
_TS__TS__TS__TS__TS_start_pos += whitespace.end();
_TS__TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS_}
_TS__TS__TS_}
_TS__TS_}
_TS__TS_self.position = start_pos;
_TS__TS_Ok(None)
_TS_}

_TS_fn get_keywords_map(&self) -> HashMap<std::string::String, std::string::String> {
_TS__TS_KEYWORDS.iter()
_TS__TS__TS_.map(|(k, v)| (k.to_string(), v.to_string()))
_TS__TS__TS_.collect()
_TS_}

_TS_fn expect_keyword(&mut self, keyword: &str) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let start_pos = self.position;
_TS__TS_let keyword_value = self.get_keywords_map().get(keyword)
_TS__TS__TS_.ok_or_else(|| format!("Unknown keyword: {}", keyword))?
_TS__TS__TS_.to_owned();
_TS__TS_if self.content[self.position..].starts_with(&keyword_value) {
_TS__TS__TS_self.position += keyword_value.len();
_TS__TS__TS_return Ok(Some(vec![Node::new_with_position(_String, vec![], Some(keyword.to_string()), start_pos, self.position)]));
_TS__TS_}
_TS__TS_self.position = start_pos;
_TS__TS_Ok(None)
_TS_}

_TS_fn eval(&mut self, expression: &Expression) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_match expression {
_TS__TS__TS_Expression::Rule(rule) => {
_TS__TS__TS__TS_if let Some(nodes) = self.call_rule(rule, true)? {
_TS__TS__TS__TS__TS_Ok(Some(nodes))
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_Ok(None)
_TS__TS__TS__TS_}
_TS__TS__TS_},
_TS__TS__TS_Expression::RegexLiteral(regex) => self.expect_regex(regex),
_TS__TS__TS_Expression::StringLiteral(string) => self.expect_string(string),
_TS__TS__TS_Expression::Keyword(keyword) => self.expect_keyword(keyword),
_TS__TS__TS_Expression::Or(left, right) => {
_TS__TS__TS__TS_let start_pos = self.position;
_TS__TS__TS__TS_let left_nodes = self.eval(&*left)?;
_TS__TS__TS__TS_let left_end = self.position;
_TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS_let right_nodes = self.eval(&*right)?;
_TS__TS__TS__TS_let right_end = self.position;

_TS__TS__TS__TS_if left_end > right_end {
_TS__TS__TS__TS__TS_self.position = left_end;
_TS__TS__TS__TS__TS_return Ok(left_nodes);
_TS__TS__TS__TS_} else if right_end > left_end {
_TS__TS__TS__TS__TS_self.position = right_end;
_TS__TS__TS__TS__TS_return Ok(right_nodes);
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS_},
_TS__TS__TS_Expression::And(left, right) => {
_TS__TS__TS__TS_let left_nodes = self.eval(&*left)?;
_TS__TS__TS__TS_if left_nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS__TS_let right_nodes = self.eval(&*right)?;
_TS__TS__TS__TS_if right_nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS__TS_let mut final_nodes = left_nodes.unwrap();
_TS__TS__TS__TS_final_nodes.extend(right_nodes.unwrap());
_TS__TS__TS__TS_Ok(Some(final_nodes))
_TS__TS__TS_},
_TS__TS__TS_Expression::DelimitRepeatOne(expression, delimiter) => {
_TS__TS__TS__TS_// Attempt to parse the first expression
_TS__TS__TS__TS_let nodes = self.eval(&*expression)?;
_TS__TS__TS__TS_// If the first expression fails, return an empty vector
_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}

_TS__TS__TS__TS_let mut nodes = nodes.unwrap();

_TS__TS__TS__TS_// Attempt to parse subsequent expressions with delimiters
_TS__TS__TS__TS_loop {
_TS__TS__TS__TS__TS_let start = self.position;
_TS__TS__TS__TS__TS_// Attempt to parse the delimiter
_TS__TS__TS__TS__TS_let delimiter_nodes = self.eval(&*delimiter)?;
_TS__TS__TS__TS__TS_// If it fails, break the loop
_TS__TS__TS__TS__TS_if delimiter_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start; // Technically unnecessary as a failure would leave position unchanged, but just to be consistent
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_// Attempt to parse the next expression
_TS__TS__TS__TS__TS_let expression_nodes = self.eval(&*expression)?;
_TS__TS__TS__TS__TS_// If the next expression fails, break the loop
_TS__TS__TS__TS__TS_if expression_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start;
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}

_TS__TS__TS__TS__TS_// Only if both delimiter and expression are successful, append them to the nodes
_TS__TS__TS__TS__TS_nodes.extend(delimiter_nodes.unwrap());
_TS__TS__TS__TS__TS_nodes.extend(expression_nodes.unwrap());

_TS__TS__TS__TS__TS_// Prevent infinite loops by checking if position has advanced
_TS__TS__TS__TS__TS_if self.position <= start {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS_}

_TS__TS__TS__TS_// Return the nodes collected so far
_TS__TS__TS__TS_Ok(Some(nodes))
_TS__TS__TS_},
_TS__TS__TS_Expression::DelimitRepeatZero(left, right) => {
_TS__TS__TS__TS_// Attempt to parse the first expression
_TS__TS__TS__TS_let nodes = self.eval(&*left)?;
_TS__TS__TS__TS_// If the first expression fails, return an empty vector
_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(Some(vec![]));
_TS__TS__TS__TS_}

_TS__TS__TS__TS_let mut nodes = nodes.unwrap();

_TS__TS__TS__TS_// Attempt to parse subsequent expressions with delimiters
_TS__TS__TS__TS_loop {
_TS__TS__TS__TS__TS_let start = self.position;
_TS__TS__TS__TS__TS_// Attempt to parse the delimiter
_TS__TS__TS__TS__TS_let delimiter_nodes = self.eval(&*right)?;
_TS__TS__TS__TS__TS_// If it fails, break the loop
_TS__TS__TS__TS__TS_if delimiter_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start; // Technically unnecessary as a failure would leave position unchanged, but just to be consistent
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_// Attempt to parse the next expression
_TS__TS__TS__TS__TS_let expression_nodes = self.eval(&*left)?;
_TS__TS__TS__TS__TS_// If the next expression fails, break the loop
_TS__TS__TS__TS__TS_if expression_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start;
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}

_TS__TS__TS__TS__TS_// Only if both delimiter and expression are successful, append them to the nodes
_TS__TS__TS__TS__TS_nodes.extend(delimiter_nodes.unwrap());
_TS__TS__TS__TS__TS_nodes.extend(expression_nodes.unwrap());

_TS__TS__TS__TS__TS_// Prevent infinite loops by checking if position has advanced
_TS__TS__TS__TS__TS_if self.position <= start {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS_}

_TS__TS__TS__TS_// Return the nodes collected so far
_TS__TS__TS__TS_Ok(Some(nodes))
_TS__TS__TS_},
_TS__TS__TS_Expression::RepeatOne(expr) => {
_TS__TS__TS__TS_let mut nodes = self.eval(&*expr)?;
_TS__TS__TS__TS_if nodes.is_none() { return Ok(None); }

_TS__TS__TS__TS_let mut last_pos = self.position;
_TS__TS__TS__TS_while let Some(new_nodes) = self.eval(&*expr)? {
_TS__TS__TS__TS__TS_nodes.as_mut().unwrap().extend(new_nodes);
_TS__TS__TS__TS__TS_if self.position == last_pos {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_last_pos = self.position;
_TS__TS__TS__TS_}

_TS__TS__TS__TS_Ok(nodes)
_TS__TS__TS_},
_TS__TS__TS_Expression::RepeatZero(expr) => {
_TS__TS__TS__TS_let mut nodes = self.eval(&*expr)?;
_TS__TS__TS__TS_if nodes.is_none() { return Ok(Some(vec![])); }

_TS__TS__TS__TS_let mut last_pos = self.position;
_TS__TS__TS__TS_while let Some(new_nodes) = self.eval(&*expr)? {
_TS__TS__TS__TS__TS_nodes.as_mut().unwrap().extend(new_nodes);
_TS__TS__TS__TS__TS_if self.position == last_pos {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_last_pos = self.position;
_TS__TS__TS__TS_}

_TS__TS__TS__TS_Ok(nodes)
_TS__TS__TS_},
_TS__TS__TS_Expression::Optional(expr) => {
_TS__TS__TS__TS_let mut nodes = self.eval(&*expr)?;

_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_nodes = Some(vec![]);
_TS__TS__TS__TS_}

_TS__TS__TS__TS_Ok(nodes)
_TS__TS__TS_},
_TS__TS__TS_Expression::Discard(expr) => {
_TS__TS__TS__TS_let nodes = self.eval(&*expr)?;
_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS__TS_let nodes = nodes.unwrap();
_TS__TS__TS__TS_if nodes.len() == 0 {
_TS__TS__TS__TS__TS_return Ok(Some(vec![]));
_TS__TS__TS__TS_}
_TS__TS__TS__TS_let last_node  = nodes[nodes.len() - 1].clone();
_TS__TS__TS__TS_let node = Node::new_with_position(_Discard, vec![], None, self.position, last_node.get_end_pos());
_TS__TS__TS__TS_Ok(Some(vec![node]))
_TS__TS__TS_}
_TS__TS__TS_Expression::Meta(expr) => {
_TS__TS__TS__TS_let nodes = self.eval(&*expr)?;
_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS__TS_// Assume that the length of nodes is 1 for Meta, and is a Rule Node
_TS__TS__TS__TS_let nodes = nodes.unwrap()[0].children.clone();
_TS__TS__TS__TS_Ok(Some(nodes))
_TS__TS__TS_}
_TS__TS_}
_TS_}

_TS_fn get_longest_expression_match(&mut self, expressions: &[Expression]) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let start_pos = self.position;
_TS__TS_let mut longest_end = start_pos;
_TS__TS_let mut longest_nodes = None;

_TS__TS_for expr in expressions.iter() {
_TS__TS__TS_let result = self.eval(&expr)?;
_TS__TS__TS_let new_end_pos = self.position;
_TS__TS__TS_self.position = start_pos; // Reset position to start for each expression evaluation
_TS__TS__TS_if new_end_pos > longest_end || longest_nodes.is_none() {
_TS__TS__TS__TS_longest_end = new_end_pos;
_TS__TS__TS__TS_longest_nodes = result;
_TS__TS__TS_}
_TS__TS_}
_TS__TS_if longest_nodes.is_none() {
_TS__TS__TS_self.position = start_pos; // Reset position if no matches found
_TS__TS_} else {
_TS__TS__TS_self.position = longest_end; // Update position to the end of the longest match
_TS__TS_}
_TS__TS_Ok(longest_nodes)
_TS_}

_TS_fn call_rule(&mut self, rule_name: &str, protected: bool) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_self.debug_log(&format!("Calling rule: {}", rule_name));
_TS__TS_match rule_name {
_RULECASES_
_TS__TS__TS__ => Err(format!("Unknown rule: {}", rule_name).into()),
_TS__TS_}
_TS_}

_RULEFUNCTIONS_

_METARULEFUNCTIONS_

_DISCARDRULEFUNCTIONS_
}

mod expression {
_TS_use std::fmt;

_TS_#[derive(Clone, PartialEq, Eq)]
_TS_#[allow(dead_code)]
_TS_pub enum Expression {
_TS__TS_Rule(&'static str),
_TS__TS_RegexLiteral(&'static str),
_TS__TS_StringLiteral(&'static str),
_TS__TS_Keyword(&'static str),
_TS__TS_Or(Box<Expression>, Box<Expression>),
_TS__TS_And(Box<Expression>, Box<Expression>),
_TS__TS_DelimitRepeatOne(Box<Expression>, Box<Expression>),
_TS__TS_DelimitRepeatZero(Box<Expression>, Box<Expression>),
_TS__TS_Optional(Box<Expression>),
_TS__TS_RepeatOne(Box<Expression>),
_TS__TS_RepeatZero(Box<Expression>),
_TS__TS_Discard(Box<Expression>),
_TS__TS_Meta(Box<Expression>),
_TS_}

_TS_impl fmt::Debug for Expression {
_TS__TS_fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
_TS__TS__TS_match self {
_TS__TS__TS__TS_Expression::Rule(rule) => write!(f, "{}", rule),
_TS__TS__TS__TS_Expression::RegexLiteral(regex) => write!(f, "{}", regex),
_TS__TS__TS__TS_Expression::StringLiteral(string) => write!(f, "{}", string),
_TS__TS__TS__TS_Expression::Keyword(keyword) => write!(f, "{}", keyword),
_TS__TS__TS__TS_Expression::Or(left, right) => write!(f, "{:?} | {:?}", left, right),
_TS__TS__TS__TS_Expression::And(left, right) => write!(f, "{:?} & {:?}", left, right),
_TS__TS__TS__TS_Expression::DelimitRepeatOne(left, right) => write!(f, "({:?}),({:?})+", left, right),
_TS__TS__TS__TS_Expression::DelimitRepeatZero(left, right) => write!(f, "({:?}),({:?})*", left, right),
_TS__TS__TS__TS_Expression::Optional(expr) => write!(f, "({:?})?", expr),
_TS__TS__TS__TS_Expression::RepeatOne(expr) => write!(f, "({:?})+", expr),
_TS__TS__TS__TS_Expression::RepeatZero(expr) => write!(f, "({:?})*", expr),
_TS__TS__TS__TS_Expression::Discard(expr) => write!(f, "~({:?})", expr),
_TS__TS__TS__TS_Expression::Meta(expr) => write!(f, "$({:?})", expr),
_TS__TS__TS_}
_TS__TS_}
_TS_}

_TS_#[allow(dead_code)]
_TS_impl Expression {
_TS__TS_pub fn or(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::Or(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn and(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::And(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn delimit_repeat_one(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::DelimitRepeatOne(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn delimit_repeat_zero(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::DelimitRepeatZero(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn optional(expr: Expression) -> Self {
_TS__TS__TS_Expression::Optional(Box::new(expr))
_TS__TS_}
_TS__TS_pub fn repeat_one(expr: Expression) -> Self {
_TS__TS__TS_Expression::RepeatOne(Box::new(expr))
_TS__TS_}
_TS__TS_pub fn repeat_zero(expr: Expression) -> Self {
_TS__TS__TS_Expression::RepeatZero(Box::new(expr))
_TS__TS_}
_TS__TS_pub fn discard(expr: Expression) -> Self {
_TS__TS__TS_Expression::Discard(Box::new(expr))
_TS__TS_}
_TS__TS_pub fn meta(expr: Expression) -> Self {
_TS__TS__TS_Expression::Meta(Box::new(expr))
_TS__TS_}
_TS_}
}

#[allow(dead_code)]
pub mod node {
_TS_#[derive(Debug, Clone, PartialEq, Eq)]
_TS_pub enum NodeType {
_PASCALCASERULENAMES_
_TS__TS__String,
_TS__TS__Discard,
_TS_}

_TS_#[derive(Debug, Clone)]
_TS_pub struct Node {
_TS__TS_pub node_type: NodeType,
_TS__TS_pub children: Vec<Node>,
_TS__TS_pub value: Option<String>,
_TS__TS_pub start_position: usize,
_TS__TS_pub end_position: usize,
_TS_}

_TS_impl Node {
_TS__TS_pub fn new(node_type: NodeType, children: Vec<Node>, value: Option<String>) -> Self {
_TS__TS__TS_Node {
_TS__TS__TS__TS_node_type,
_TS__TS__TS__TS_children,
_TS__TS__TS__TS_value,
_TS__TS__TS__TS_start_position: 0,
_TS__TS__TS__TS_end_position: 0,
_TS__TS__TS_}
_TS__TS_}

_TS__TS_pub fn formatted(&self, indent: usize, indent_string: &str) -> String {
_TS__TS__TS_let mut result = String::new();
_TS__TS__TS_let indent_str = indent_string.repeat(indent);
_TS__TS__TS_result.push_str(&indent_str);
_TS__TS__TS_if self.node_type != NodeType::_String {
_TS__TS__TS__TS_result.push_str(&format!("{:?}: ", self.node_type));
_TS__TS__TS_}
_TS__TS__TS_if let Some(val) = &self.value {
_TS__TS__TS__TS_result.push_str(&format!("\"{}\"", val.escape_debug()));
_TS__TS__TS_}
_TS__TS__TS_for child in &self.children {
_TS__TS__TS__TS_result.push_str(&format!("\n{}", child.formatted(indent + 1, indent_string)));
_TS__TS__TS_}
_TS__TS__TS_result
_TS__TS_}

_TS__TS_pub fn pretty_print(&self) {
_TS__TS__TS_println!("{}", self.formatted(0, "_TS_"));
_TS__TS_}

_TS__TS_pub(super) fn extend(&mut self, children: &Vec<Node>) {
_TS__TS__TS_self.children.extend(children.iter().cloned());
_TS__TS_}

_TS__TS_pub(super) fn new_with_position(
_TS__TS__TS_node_type: NodeType,
_TS__TS__TS_children: Vec<Node>,
_TS__TS__TS_value: Option<String>,
_TS__TS__TS_start_position: usize,
_TS__TS__TS_end_position: usize,
_TS__TS_) -> Self {
_TS__TS__TS_Node {
_TS__TS__TS__TS_node_type,
_TS__TS__TS__TS_children,
_TS__TS__TS__TS_value,
_TS__TS__TS__TS_start_position,
_TS__TS__TS__TS_end_position,
_TS__TS__TS_}
_TS__TS_}

_TS__TS_pub(super) fn get_end_pos(&self) -> usize {
_TS__TS__TS_if let Some(last_child) = self.children.last() {
_TS__TS__TS__TS_last_child.get_end_pos()
_TS__TS__TS_} else {
_TS__TS__TS__TS_self.end_position
_TS__TS__TS_}
_TS__TS_}

_TS__TS_pub(super) fn append(&mut self, child: Node) {
_TS__TS__TS_self.children.push(child);
_TS__TS_}
_TS_}
}