use std::error::Error;
use std::collections::HashMap;
use regex::Regex;

use expression::Expression::{self, *};

const KEYWORDS: &[(&str, &str)] = &[
_TS_("ENDMARKER", "0"),
];

#[allow(dead_code)]
pub struct _PARSERNAME_ {
_TS_pub position: usize,

_TS_content: String,
_TS_memos: HashMap<usize, HashMap<String, Box<Option<Vec<Node>>>>>,
}

#[allow(dead_code)]
impl _PARSERNAME_ {
_TS_pub fn new() -> Self {
_TS__TS__PARSERNAME_ { content: String::new(), position: 0, memos: HashMap::new() }
_TS_}

_TS_pub fn parse(&mut self, input: String) -> Result<Option<Node>, Box<dyn Error>> {
_TS__TS_self.position = 0;
_TS__TS_self.content = input;
_TS__TS_if let Some(nodes) = self.__ENTRYRULE_()? {
_TS__TS__TS_return Ok(Some(nodes[0].clone()));
_TS__TS_}
_TS__TS_Ok(None)
_TS_}

_TS_pub fn parse_file(&mut self, file_path: &str) -> Result<Option<Node>, Box<dyn Error>> {
_TS__TS_let content = std::fs::read_to_string(file_path)?;
_TS__TS_self.parse(content)
_TS_}

_TS_fn circular_wrapper(&mut self, rule_name: String) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let pos = self.position;

_TS__TS_if let Some(cached_result_box) = self.memos.get(&pos).and_then(|memo| memo.get(&rule_name)) {
_TS__TS__TS_let cached_result = *cached_result_box.clone();

_TS__TS__TS_let end_pos = cached_result.as_ref()
_TS__TS__TS__TS_.and_then(|nodes| nodes.iter().map(|n| n.get_end_pos()).max())
_TS__TS__TS__TS_.unwrap_or(pos);
_TS__TS__TS_self.position = end_pos;

_TS__TS__TS_return Ok(cached_result);
_TS__TS_}

_TS__TS_self.memos.entry(pos).or_insert_with(HashMap::new).insert(rule_name.clone(), Box::new(None));

_TS__TS_let mut last_result = None;
_TS__TS_let mut last_pos = pos;

_TS__TS_loop {
_TS__TS__TS_self.position = pos;

_TS__TS__TS_let result = self.call_rule(&rule_name, false)?;
_TS__TS__TS_let end_pos = self.position;

_TS__TS__TS_if end_pos <= last_pos {
_TS__TS__TS__TS_break;
_TS__TS__TS_}

_TS__TS__TS_last_result = result;
_TS__TS__TS_last_pos = end_pos;

_TS__TS__TS_if let Some(memo) = self.memos.get_mut(&pos) {
_TS__TS__TS__TS_memo.insert(rule_name.clone(), Box::new(last_result.clone()));
_TS__TS__TS_}
_TS__TS_}

_TS__TS_self.position = last_pos;
_TS__TS_Ok(last_result)
_TS_}

_TS_fn expect_string(&mut self, string: &str) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let mut start_pos = self.position;
_TS__TS_loop {
_TS__TS__TS_if self.content[self.position..].starts_with(string) {
_TS__TS__TS__TS_self.position += string.len();
_TS__TS__TS__TS_return Ok(Some(vec![Node::String(string.to_string(), start_pos)]));
_TS__TS__TS_} else {
_TS__TS__TS__TS_if let Some(whitespace) = Regex::new(r"^\s+").unwrap().find(&self.content[self.position..]) {
_TS__TS__TS__TS__TS_start_pos += whitespace.end();
_TS__TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS_}
_TS__TS__TS_}
_TS__TS_}
_TS__TS_self.position = start_pos;
_TS__TS_Ok(None)
_TS_}

_TS_fn expect_regex(&mut self, regex: &str) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let mut start_pos = self.position;
_TS__TS_loop {
_TS__TS__TS_if let Some(captures) = Regex::new(regex).unwrap().captures(&self.content[self.position..]) {
_TS__TS__TS__TS_self.position += captures.get(0).unwrap().end();
_TS__TS__TS__TS_return Ok(Some(vec![Node::String(captures.get(0).unwrap().as_str().to_string(), start_pos)]));
_TS__TS__TS_} else {
_TS__TS__TS__TS_if let Some(whitespace) = Regex::new(r"^\s+").unwrap().find(&self.content[self.position..]) {
_TS__TS__TS__TS__TS_start_pos += whitespace.end();
_TS__TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS_}
_TS__TS__TS_}
_TS__TS_}
_TS__TS_self.position = start_pos;
_TS__TS_Ok(None)
_TS_}

_TS_fn get_keywords_map(&self) -> HashMap<String, String> {
_TS__TS_KEYWORDS.iter()
_TS__TS__TS_.map(|(k, v)| (k.to_string(), v.to_string()))
_TS__TS__TS_.collect()
_TS_}

_TS_fn expect_keyword(&mut self, keyword: &str) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let start_pos = self.position;
_TS__TS_let keyword_value = self.get_keywords_map().get(keyword)
_TS__TS__TS_.ok_or_else(|| format!("Unknown keyword: {}", keyword))?
_TS__TS__TS_.to_owned();
_TS__TS_if self.content[self.position..].starts_with(&keyword_value) {
_TS__TS__TS_self.position += keyword_value.len();
_TS__TS__TS_return Ok(Some(vec![Node::String(keyword.to_string(), start_pos)]));
_TS__TS_}
_TS__TS_self.position = start_pos;
_TS__TS_Ok(None)
_TS_}

_TS_fn eval(&mut self, expression: &Expression) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_match expression {
_TS__TS__TS_Expression::Rule(rule) => {
_TS__TS__TS__TS_if let Some(nodes) = self.call_rule(rule, true)? {
_TS__TS__TS__TS__TS_Ok(Some(nodes))
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_Ok(None)
_TS__TS__TS__TS_}
_TS__TS__TS_},
_TS__TS__TS_Expression::RegexLiteral(regex) => self.expect_regex(regex),
_TS__TS__TS_Expression::StringLiteral(string) => self.expect_string(string),
_TS__TS__TS_Expression::Keyword(keyword) => self.expect_keyword(keyword),
_TS__TS__TS_Expression::Or(left, right) => {
_TS__TS__TS__TS_let start_pos = self.position;
_TS__TS__TS__TS_let left_nodes = self.eval(&*left)?;
_TS__TS__TS__TS_let left_end = self.position;
_TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS_let right_nodes = self.eval(&*right)?;
_TS__TS__TS__TS_let right_end = self.position;

_TS__TS__TS__TS_if left_end > right_end {
_TS__TS__TS__TS__TS_self.position = left_end;
_TS__TS__TS__TS__TS_return Ok(left_nodes);
_TS__TS__TS__TS_} else if right_end > left_end {
_TS__TS__TS__TS__TS_self.position = right_end;
_TS__TS__TS__TS__TS_return Ok(right_nodes);
_TS__TS__TS__TS_} else {
_TS__TS__TS__TS__TS_self.position = start_pos;
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS_},
_TS__TS__TS_Expression::And(left, right) => {
_TS__TS__TS__TS_let left_nodes = self.eval(&*left)?;
_TS__TS__TS__TS_if left_nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS__TS_let right_nodes = self.eval(&*right)?;
_TS__TS__TS__TS_if right_nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}
_TS__TS__TS__TS_let mut final_nodes = left_nodes.unwrap();
_TS__TS__TS__TS_final_nodes.extend(right_nodes.unwrap());
_TS__TS__TS__TS_Ok(Some(final_nodes))
_TS__TS__TS_},
_TS__TS__TS_Expression::DelimitRepeatOne(expression, delimiter) => {
_TS__TS__TS__TS_// Attempt to parse the first expression
_TS__TS__TS__TS_let nodes = self.eval(&*expression)?;
_TS__TS__TS__TS_// If the first expression fails, return an empty vector
_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(None);
_TS__TS__TS__TS_}

_TS__TS__TS__TS_let mut nodes = nodes.unwrap();

_TS__TS__TS__TS_// Attempt to parse subsequent expressions with delimiters
_TS__TS__TS__TS_loop {
_TS__TS__TS__TS__TS_let start = self.position;
_TS__TS__TS__TS__TS_// Attempt to parse the delimiter
_TS__TS__TS__TS__TS_let delimiter_nodes = self.eval(&*delimiter)?;
_TS__TS__TS__TS__TS_// If it fails, break the loop
_TS__TS__TS__TS__TS_if delimiter_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start; // Technically unnecessary as a failure would leave position unchanged, but just to be consistent
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_// Attempt to parse the next expression
_TS__TS__TS__TS__TS_let expression_nodes = self.eval(&*expression)?;
_TS__TS__TS__TS__TS_// If the next expression fails, break the loop
_TS__TS__TS__TS__TS_if expression_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start;
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}

_TS__TS__TS__TS__TS_// Only if both delimiter and expression are successful, append them to the nodes
_TS__TS__TS__TS__TS_nodes.extend(delimiter_nodes.unwrap());
_TS__TS__TS__TS__TS_nodes.extend(expression_nodes.unwrap());

_TS__TS__TS__TS__TS_// Prevent infinite loops by checking if position has advanced
_TS__TS__TS__TS__TS_if self.position <= start {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS_}

_TS__TS__TS__TS_// Return the nodes collected so far
_TS__TS__TS__TS_Ok(Some(nodes))
_TS__TS__TS_},
_TS__TS__TS_Expression::DelimitRepeatZero(left, right) => {
_TS__TS__TS__TS_// Attempt to parse the first expression
_TS__TS__TS__TS_let nodes = self.eval(&*left)?;
_TS__TS__TS__TS_// If the first expression fails, return an empty vector
_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_return Ok(Some(vec![]));
_TS__TS__TS__TS_}

_TS__TS__TS__TS_let mut nodes = nodes.unwrap();

_TS__TS__TS__TS_// Attempt to parse subsequent expressions with delimiters
_TS__TS__TS__TS_loop {
_TS__TS__TS__TS__TS_let start = self.position;
_TS__TS__TS__TS__TS_// Attempt to parse the delimiter
_TS__TS__TS__TS__TS_let delimiter_nodes = self.eval(&*right)?;
_TS__TS__TS__TS__TS_// If it fails, break the loop
_TS__TS__TS__TS__TS_if delimiter_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start; // Technically unnecessary as a failure would leave position unchanged, but just to be consistent
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_// Attempt to parse the next expression
_TS__TS__TS__TS__TS_let expression_nodes = self.eval(&*left)?;
_TS__TS__TS__TS__TS_// If the next expression fails, break the loop
_TS__TS__TS__TS__TS_if expression_nodes.is_none() {
_TS__TS__TS__TS__TS__TS_self.position = start;
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}

_TS__TS__TS__TS__TS_// Only if both delimiter and expression are successful, append them to the nodes
_TS__TS__TS__TS__TS_nodes.extend(delimiter_nodes.unwrap());
_TS__TS__TS__TS__TS_nodes.extend(expression_nodes.unwrap());

_TS__TS__TS__TS__TS_// Prevent infinite loops by checking if position has advanced
_TS__TS__TS__TS__TS_if self.position <= start {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS_}

_TS__TS__TS__TS_// Return the nodes collected so far
_TS__TS__TS__TS_Ok(Some(nodes))
_TS__TS__TS_},
_TS__TS__TS_Expression::RepeatOne(expr) => {
_TS__TS__TS__TS_let mut nodes = self.eval(&*expr)?;
_TS__TS__TS__TS_if nodes.is_none() { return Ok(None); }

_TS__TS__TS__TS_let mut last_pos = self.position;
_TS__TS__TS__TS_while let Some(new_nodes) = self.eval(&*expr)? {
_TS__TS__TS__TS__TS_nodes.as_mut().unwrap().extend(new_nodes);
_TS__TS__TS__TS__TS_if self.position == last_pos {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_last_pos = self.position;
_TS__TS__TS__TS_}

_TS__TS__TS__TS_Ok(nodes)
_TS__TS__TS_},
_TS__TS__TS_Expression::RepeatZero(expr) => {
_TS__TS__TS__TS_let mut nodes = self.eval(&*expr)?;
_TS__TS__TS__TS_if nodes.is_none() { return Ok(Some(vec![])); }

_TS__TS__TS__TS_let mut last_pos = self.position;
_TS__TS__TS__TS_while let Some(new_nodes) = self.eval(&*expr)? {
_TS__TS__TS__TS__TS_nodes.as_mut().unwrap().extend(new_nodes);
_TS__TS__TS__TS__TS_if self.position == last_pos {
_TS__TS__TS__TS__TS__TS_break;
_TS__TS__TS__TS__TS_}
_TS__TS__TS__TS__TS_last_pos = self.position;
_TS__TS__TS__TS_}

_TS__TS__TS__TS_Ok(nodes)
_TS__TS__TS_},
_TS__TS__TS_Expression::Optional(expr) => {
_TS__TS__TS__TS_let mut nodes = self.eval(&*expr)?;

_TS__TS__TS__TS_if nodes.is_none() {
_TS__TS__TS__TS__TS_nodes = Some(vec![]);
_TS__TS__TS__TS_}

_TS__TS__TS__TS_Ok(nodes)
_TS__TS__TS_},
_TS__TS_}
_TS_}

_TS_fn get_longest_expression_match(&mut self, expressions: &[Expression]) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_let start_pos = self.position;
_TS__TS_let mut longest_end = start_pos;
_TS__TS_let mut longest_nodes = None;

_TS__TS_for expr in expressions.iter() {
_TS__TS__TS_let result = self.eval(&expr)?;
_TS__TS__TS_let new_end_pos = self.position;
_TS__TS__TS_self.position = start_pos; // Reset position to start for each expression evaluation
_TS__TS__TS_if new_end_pos > longest_end || longest_nodes.is_none() {
_TS__TS__TS__TS_longest_end = new_end_pos;
_TS__TS__TS__TS_longest_nodes = result;
_TS__TS__TS_}
_TS__TS_}
_TS__TS_if longest_nodes.is_none() {
_TS__TS__TS_self.position = start_pos; // Reset position if no matches found
_TS__TS_} else {
_TS__TS__TS_self.position = longest_end; // Update position to the end of the longest match
_TS__TS_}
_TS__TS_Ok(longest_nodes)
_TS_}

_TS_fn call_rule(&mut self, rule_name: &str, protected: bool) -> Result<Option<Vec<Node>>, Box<dyn Error>> {
_TS__TS_match rule_name {
_RULECASES_
_TS__TS__TS__ => Err(format!("Unknown rule: {}", rule_name).into()),
_TS__TS_}
_TS_}

_RULEFUNCTIONS_

_METARULEFUNCTIONS_
}

mod expression {
_TS_use std::fmt;

_TS_#[derive(Clone)]
_TS_#[allow(dead_code)]
_TS_pub enum Expression {
_TS__TS_Rule(&'static str),
_TS__TS_RegexLiteral(&'static str),
_TS__TS_StringLiteral(&'static str),
_TS__TS_Keyword(&'static str),
_TS__TS_Or(Box<Expression>, Box<Expression>),
_TS__TS_And(Box<Expression>, Box<Expression>),
_TS__TS_DelimitRepeatOne(Box<Expression>, Box<Expression>),
_TS__TS_DelimitRepeatZero(Box<Expression>, Box<Expression>),
_TS__TS_Optional(Box<Expression>),
_TS__TS_RepeatOne(Box<Expression>),
_TS__TS_RepeatZero(Box<Expression>),
_TS_}

_TS_impl fmt::Debug for Expression {
_TS__TS_fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
_TS__TS__TS_match self {
_TS__TS__TS__TS_Expression::Rule(rule) => write!(f, "{}", rule),
_TS__TS__TS__TS_Expression::RegexLiteral(regex) => write!(f, "{}", regex),
_TS__TS__TS__TS_Expression::StringLiteral(string) => write!(f, "{}", string),
_TS__TS__TS__TS_Expression::Keyword(keyword) => write!(f, "{}", keyword),
_TS__TS__TS__TS_Expression::Or(left, right) => write!(f, "{:?} | {:?}", left, right),
_TS__TS__TS__TS_Expression::And(left, right) => write!(f, "{:?} & {:?}", left, right),
_TS__TS__TS__TS_Expression::DelimitRepeatOne(left, right) => write!(f, "({:?}),({:?})+", left, right),
_TS__TS__TS__TS_Expression::DelimitRepeatZero(left, right) => write!(f, "({:?}),({:?})*", left, right),
_TS__TS__TS__TS_Expression::Optional(expr) => write!(f, "({:?})?", expr),
_TS__TS__TS__TS_Expression::RepeatOne(expr) => write!(f, "({:?})+", expr),
_TS__TS__TS__TS_Expression::RepeatZero(expr) => write!(f, "({:?})*", expr),
_TS__TS__TS_}
_TS__TS_}
_TS_}

_TS_#[allow(dead_code)]
_TS_impl Expression {
_TS__TS_pub fn or(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::Or(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn and(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::And(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn delimit_repeat_one(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::DelimitRepeatOne(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn delimit_repeat_zero(left: Expression, right: Expression) -> Self {
_TS__TS__TS_Expression::DelimitRepeatZero(Box::new(left), Box::new(right))
_TS__TS_}
_TS__TS_pub fn optional(expr: Expression) -> Self {
_TS__TS__TS_Expression::Optional(Box::new(expr))
_TS__TS_}
_TS__TS_pub fn repeat_one(expr: Expression) -> Self {
_TS__TS__TS_Expression::RepeatOne(Box::new(expr))
_TS__TS_}
_TS__TS_pub fn repeat_zero(expr: Expression) -> Self {
_TS__TS__TS_Expression::RepeatZero(Box::new(expr))
_TS__TS_}
_TS_}
}

#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Node {
_TS_Rule(String, Vec<Box<Node>>, usize),
_TS_String(String, usize),
}

#[allow(dead_code)]
impl Node {
_TS_pub fn append(&mut self, child: Node) {
_TS__TS_match self {
_TS__TS__TS_Node::Rule(_, children, _) => children.push(Box::new(child)),
_TS__TS__TS__ => return,
_TS__TS_}
_TS_}

_TS_pub fn extend(&mut self, children: Vec<Node>) {
_TS__TS_// Only extend if the current node can be extended
_TS__TS_if !matches!(self, Node::Rule(_, _, _)) { return; }
_TS__TS_// Extend the current node with the provided children
_TS__TS_for child in children {
_TS__TS__TS_self.append(child);
_TS__TS_}
_TS_}

_TS_pub fn set_children(&mut self, children: Vec<Node>) {
_TS__TS_match self {
_TS__TS__TS_Node::Rule(name, _, start_pos) => {
_TS__TS__TS__TS_*self = Node::Rule(name.to_string(), children.into_iter().map(|n| Box::new(n)).collect(), *start_pos);
_TS__TS__TS_},
_TS__TS__TS__ => return,
_TS__TS_}
_TS_}

_TS_pub fn get_end_pos(&self) -> usize {
_TS__TS_match self {
_TS__TS__TS_Node::Rule(_, nodes, start_pos) => {
_TS__TS__TS__TS_nodes.iter().map(|n| n.get_end_pos()).max().unwrap_or(*start_pos)
_TS__TS__TS_},
_TS__TS__TS_Node::String(string, start_pos) => *start_pos + string.len(),
_TS__TS_}
_TS_}

_TS_pub fn pretty_print(&self, indent: usize) -> String {
_TS__TS_let mut result = String::new();
_TS__TS_let indent_str = "_TS_".repeat(indent);
_TS__TS_match self {
_TS__TS__TS_Node::Rule(name, children, _) => {
_TS__TS__TS__TS_result.push_str(&format!("{}{}:", indent_str, name));
_TS__TS__TS__TS_for child in children {
_TS__TS__TS__TS__TS_result.push_str(&format!("\n{}", child.pretty_print(indent + 1)));
_TS__TS__TS__TS_}
_TS__TS__TS_},
_TS__TS__TS_Node::String(string, _) => {
_TS__TS__TS__TS_result.push_str(&format!("{}\"{}\"", indent_str, string.escape_debug()));
_TS__TS__TS_},
_TS__TS_}
_TS__TS_result
_TS_}
}